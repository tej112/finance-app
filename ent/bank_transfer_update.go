// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"finance/ent/bank"
	"finance/ent/bank_transfer"
	"finance/ent/predicate"
	"finance/ent/transaction"
	"fmt"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
	"github.com/google/uuid"
)

// BankTransferUpdate is the builder for updating Bank_Transfer entities.
type BankTransferUpdate struct {
	config
	hooks    []Hook
	mutation *BankTransferMutation
}

// Where appends a list predicates to the BankTransferUpdate builder.
func (btu *BankTransferUpdate) Where(ps ...predicate.Bank_Transfer) *BankTransferUpdate {
	btu.mutation.Where(ps...)
	return btu
}

// SetAmount sets the "amount" field.
func (btu *BankTransferUpdate) SetAmount(f float64) *BankTransferUpdate {
	btu.mutation.ResetAmount()
	btu.mutation.SetAmount(f)
	return btu
}

// SetNillableAmount sets the "amount" field if the given value is not nil.
func (btu *BankTransferUpdate) SetNillableAmount(f *float64) *BankTransferUpdate {
	if f != nil {
		btu.SetAmount(*f)
	}
	return btu
}

// AddAmount adds f to the "amount" field.
func (btu *BankTransferUpdate) AddAmount(f float64) *BankTransferUpdate {
	btu.mutation.AddAmount(f)
	return btu
}

// SetFromBankID sets the "from_bank_id" field.
func (btu *BankTransferUpdate) SetFromBankID(u uuid.UUID) *BankTransferUpdate {
	btu.mutation.SetFromBankID(u)
	return btu
}

// SetNillableFromBankID sets the "from_bank_id" field if the given value is not nil.
func (btu *BankTransferUpdate) SetNillableFromBankID(u *uuid.UUID) *BankTransferUpdate {
	if u != nil {
		btu.SetFromBankID(*u)
	}
	return btu
}

// SetToBankID sets the "to_bank_id" field.
func (btu *BankTransferUpdate) SetToBankID(u uuid.UUID) *BankTransferUpdate {
	btu.mutation.SetToBankID(u)
	return btu
}

// SetNillableToBankID sets the "to_bank_id" field if the given value is not nil.
func (btu *BankTransferUpdate) SetNillableToBankID(u *uuid.UUID) *BankTransferUpdate {
	if u != nil {
		btu.SetToBankID(*u)
	}
	return btu
}

// SetTransactionDate sets the "transaction_date" field.
func (btu *BankTransferUpdate) SetTransactionDate(t time.Time) *BankTransferUpdate {
	btu.mutation.SetTransactionDate(t)
	return btu
}

// SetNillableTransactionDate sets the "transaction_date" field if the given value is not nil.
func (btu *BankTransferUpdate) SetNillableTransactionDate(t *time.Time) *BankTransferUpdate {
	if t != nil {
		btu.SetTransactionDate(*t)
	}
	return btu
}

// SetNotes sets the "notes" field.
func (btu *BankTransferUpdate) SetNotes(s string) *BankTransferUpdate {
	btu.mutation.SetNotes(s)
	return btu
}

// SetNillableNotes sets the "notes" field if the given value is not nil.
func (btu *BankTransferUpdate) SetNillableNotes(s *string) *BankTransferUpdate {
	if s != nil {
		btu.SetNotes(*s)
	}
	return btu
}

// ClearNotes clears the value of the "notes" field.
func (btu *BankTransferUpdate) ClearNotes() *BankTransferUpdate {
	btu.mutation.ClearNotes()
	return btu
}

// SetCreatedAt sets the "created_at" field.
func (btu *BankTransferUpdate) SetCreatedAt(t time.Time) *BankTransferUpdate {
	btu.mutation.SetCreatedAt(t)
	return btu
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (btu *BankTransferUpdate) SetNillableCreatedAt(t *time.Time) *BankTransferUpdate {
	if t != nil {
		btu.SetCreatedAt(*t)
	}
	return btu
}

// SetUpdatedAt sets the "updated_at" field.
func (btu *BankTransferUpdate) SetUpdatedAt(t time.Time) *BankTransferUpdate {
	btu.mutation.SetUpdatedAt(t)
	return btu
}

// SetFromBank sets the "from_bank" edge to the Bank entity.
func (btu *BankTransferUpdate) SetFromBank(b *Bank) *BankTransferUpdate {
	return btu.SetFromBankID(b.ID)
}

// SetToBank sets the "to_bank" edge to the Bank entity.
func (btu *BankTransferUpdate) SetToBank(b *Bank) *BankTransferUpdate {
	return btu.SetToBankID(b.ID)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by IDs.
func (btu *BankTransferUpdate) AddTransactionIDs(ids ...uuid.UUID) *BankTransferUpdate {
	btu.mutation.AddTransactionIDs(ids...)
	return btu
}

// AddTransactions adds the "transactions" edges to the Transaction entity.
func (btu *BankTransferUpdate) AddTransactions(t ...*Transaction) *BankTransferUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return btu.AddTransactionIDs(ids...)
}

// Mutation returns the BankTransferMutation object of the builder.
func (btu *BankTransferUpdate) Mutation() *BankTransferMutation {
	return btu.mutation
}

// ClearFromBank clears the "from_bank" edge to the Bank entity.
func (btu *BankTransferUpdate) ClearFromBank() *BankTransferUpdate {
	btu.mutation.ClearFromBank()
	return btu
}

// ClearToBank clears the "to_bank" edge to the Bank entity.
func (btu *BankTransferUpdate) ClearToBank() *BankTransferUpdate {
	btu.mutation.ClearToBank()
	return btu
}

// ClearTransactions clears all "transactions" edges to the Transaction entity.
func (btu *BankTransferUpdate) ClearTransactions() *BankTransferUpdate {
	btu.mutation.ClearTransactions()
	return btu
}

// RemoveTransactionIDs removes the "transactions" edge to Transaction entities by IDs.
func (btu *BankTransferUpdate) RemoveTransactionIDs(ids ...uuid.UUID) *BankTransferUpdate {
	btu.mutation.RemoveTransactionIDs(ids...)
	return btu
}

// RemoveTransactions removes "transactions" edges to Transaction entities.
func (btu *BankTransferUpdate) RemoveTransactions(t ...*Transaction) *BankTransferUpdate {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return btu.RemoveTransactionIDs(ids...)
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (btu *BankTransferUpdate) Save(ctx context.Context) (int, error) {
	btu.defaults()
	return withHooks(ctx, btu.sqlSave, btu.mutation, btu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (btu *BankTransferUpdate) SaveX(ctx context.Context) int {
	affected, err := btu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (btu *BankTransferUpdate) Exec(ctx context.Context) error {
	_, err := btu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (btu *BankTransferUpdate) ExecX(ctx context.Context) {
	if err := btu.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (btu *BankTransferUpdate) defaults() {
	if _, ok := btu.mutation.UpdatedAt(); !ok {
		v := bank_transfer.UpdateDefaultUpdatedAt()
		btu.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (btu *BankTransferUpdate) check() error {
	if v, ok := btu.mutation.Amount(); ok {
		if err := bank_transfer.AmountValidator(v); err != nil {
			return &ValidationError{Name: "amount", err: fmt.Errorf(`ent: validator failed for field "Bank_Transfer.amount": %w`, err)}
		}
	}
	if btu.mutation.FromBankCleared() && len(btu.mutation.FromBankIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Bank_Transfer.from_bank"`)
	}
	if btu.mutation.ToBankCleared() && len(btu.mutation.ToBankIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Bank_Transfer.to_bank"`)
	}
	return nil
}

func (btu *BankTransferUpdate) sqlSave(ctx context.Context) (n int, err error) {
	if err := btu.check(); err != nil {
		return n, err
	}
	_spec := sqlgraph.NewUpdateSpec(bank_transfer.Table, bank_transfer.Columns, sqlgraph.NewFieldSpec(bank_transfer.FieldID, field.TypeUUID))
	if ps := btu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := btu.mutation.Amount(); ok {
		_spec.SetField(bank_transfer.FieldAmount, field.TypeFloat64, value)
	}
	if value, ok := btu.mutation.AddedAmount(); ok {
		_spec.AddField(bank_transfer.FieldAmount, field.TypeFloat64, value)
	}
	if value, ok := btu.mutation.TransactionDate(); ok {
		_spec.SetField(bank_transfer.FieldTransactionDate, field.TypeTime, value)
	}
	if value, ok := btu.mutation.Notes(); ok {
		_spec.SetField(bank_transfer.FieldNotes, field.TypeString, value)
	}
	if btu.mutation.NotesCleared() {
		_spec.ClearField(bank_transfer.FieldNotes, field.TypeString)
	}
	if value, ok := btu.mutation.CreatedAt(); ok {
		_spec.SetField(bank_transfer.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := btu.mutation.UpdatedAt(); ok {
		_spec.SetField(bank_transfer.FieldUpdatedAt, field.TypeTime, value)
	}
	if btu.mutation.FromBankCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bank_transfer.FromBankTable,
			Columns: []string{bank_transfer.FromBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(bank.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := btu.mutation.FromBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bank_transfer.FromBankTable,
			Columns: []string{bank_transfer.FromBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(bank.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if btu.mutation.ToBankCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bank_transfer.ToBankTable,
			Columns: []string{bank_transfer.ToBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(bank.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := btu.mutation.ToBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bank_transfer.ToBankTable,
			Columns: []string{bank_transfer.ToBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(bank.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if btu.mutation.TransactionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   bank_transfer.TransactionsTable,
			Columns: []string{bank_transfer.TransactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(transaction.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := btu.mutation.RemovedTransactionsIDs(); len(nodes) > 0 && !btu.mutation.TransactionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   bank_transfer.TransactionsTable,
			Columns: []string{bank_transfer.TransactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(transaction.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := btu.mutation.TransactionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   bank_transfer.TransactionsTable,
			Columns: []string{bank_transfer.TransactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(transaction.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, btu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{bank_transfer.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	btu.mutation.done = true
	return n, nil
}

// BankTransferUpdateOne is the builder for updating a single Bank_Transfer entity.
type BankTransferUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *BankTransferMutation
}

// SetAmount sets the "amount" field.
func (btuo *BankTransferUpdateOne) SetAmount(f float64) *BankTransferUpdateOne {
	btuo.mutation.ResetAmount()
	btuo.mutation.SetAmount(f)
	return btuo
}

// SetNillableAmount sets the "amount" field if the given value is not nil.
func (btuo *BankTransferUpdateOne) SetNillableAmount(f *float64) *BankTransferUpdateOne {
	if f != nil {
		btuo.SetAmount(*f)
	}
	return btuo
}

// AddAmount adds f to the "amount" field.
func (btuo *BankTransferUpdateOne) AddAmount(f float64) *BankTransferUpdateOne {
	btuo.mutation.AddAmount(f)
	return btuo
}

// SetFromBankID sets the "from_bank_id" field.
func (btuo *BankTransferUpdateOne) SetFromBankID(u uuid.UUID) *BankTransferUpdateOne {
	btuo.mutation.SetFromBankID(u)
	return btuo
}

// SetNillableFromBankID sets the "from_bank_id" field if the given value is not nil.
func (btuo *BankTransferUpdateOne) SetNillableFromBankID(u *uuid.UUID) *BankTransferUpdateOne {
	if u != nil {
		btuo.SetFromBankID(*u)
	}
	return btuo
}

// SetToBankID sets the "to_bank_id" field.
func (btuo *BankTransferUpdateOne) SetToBankID(u uuid.UUID) *BankTransferUpdateOne {
	btuo.mutation.SetToBankID(u)
	return btuo
}

// SetNillableToBankID sets the "to_bank_id" field if the given value is not nil.
func (btuo *BankTransferUpdateOne) SetNillableToBankID(u *uuid.UUID) *BankTransferUpdateOne {
	if u != nil {
		btuo.SetToBankID(*u)
	}
	return btuo
}

// SetTransactionDate sets the "transaction_date" field.
func (btuo *BankTransferUpdateOne) SetTransactionDate(t time.Time) *BankTransferUpdateOne {
	btuo.mutation.SetTransactionDate(t)
	return btuo
}

// SetNillableTransactionDate sets the "transaction_date" field if the given value is not nil.
func (btuo *BankTransferUpdateOne) SetNillableTransactionDate(t *time.Time) *BankTransferUpdateOne {
	if t != nil {
		btuo.SetTransactionDate(*t)
	}
	return btuo
}

// SetNotes sets the "notes" field.
func (btuo *BankTransferUpdateOne) SetNotes(s string) *BankTransferUpdateOne {
	btuo.mutation.SetNotes(s)
	return btuo
}

// SetNillableNotes sets the "notes" field if the given value is not nil.
func (btuo *BankTransferUpdateOne) SetNillableNotes(s *string) *BankTransferUpdateOne {
	if s != nil {
		btuo.SetNotes(*s)
	}
	return btuo
}

// ClearNotes clears the value of the "notes" field.
func (btuo *BankTransferUpdateOne) ClearNotes() *BankTransferUpdateOne {
	btuo.mutation.ClearNotes()
	return btuo
}

// SetCreatedAt sets the "created_at" field.
func (btuo *BankTransferUpdateOne) SetCreatedAt(t time.Time) *BankTransferUpdateOne {
	btuo.mutation.SetCreatedAt(t)
	return btuo
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (btuo *BankTransferUpdateOne) SetNillableCreatedAt(t *time.Time) *BankTransferUpdateOne {
	if t != nil {
		btuo.SetCreatedAt(*t)
	}
	return btuo
}

// SetUpdatedAt sets the "updated_at" field.
func (btuo *BankTransferUpdateOne) SetUpdatedAt(t time.Time) *BankTransferUpdateOne {
	btuo.mutation.SetUpdatedAt(t)
	return btuo
}

// SetFromBank sets the "from_bank" edge to the Bank entity.
func (btuo *BankTransferUpdateOne) SetFromBank(b *Bank) *BankTransferUpdateOne {
	return btuo.SetFromBankID(b.ID)
}

// SetToBank sets the "to_bank" edge to the Bank entity.
func (btuo *BankTransferUpdateOne) SetToBank(b *Bank) *BankTransferUpdateOne {
	return btuo.SetToBankID(b.ID)
}

// AddTransactionIDs adds the "transactions" edge to the Transaction entity by IDs.
func (btuo *BankTransferUpdateOne) AddTransactionIDs(ids ...uuid.UUID) *BankTransferUpdateOne {
	btuo.mutation.AddTransactionIDs(ids...)
	return btuo
}

// AddTransactions adds the "transactions" edges to the Transaction entity.
func (btuo *BankTransferUpdateOne) AddTransactions(t ...*Transaction) *BankTransferUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return btuo.AddTransactionIDs(ids...)
}

// Mutation returns the BankTransferMutation object of the builder.
func (btuo *BankTransferUpdateOne) Mutation() *BankTransferMutation {
	return btuo.mutation
}

// ClearFromBank clears the "from_bank" edge to the Bank entity.
func (btuo *BankTransferUpdateOne) ClearFromBank() *BankTransferUpdateOne {
	btuo.mutation.ClearFromBank()
	return btuo
}

// ClearToBank clears the "to_bank" edge to the Bank entity.
func (btuo *BankTransferUpdateOne) ClearToBank() *BankTransferUpdateOne {
	btuo.mutation.ClearToBank()
	return btuo
}

// ClearTransactions clears all "transactions" edges to the Transaction entity.
func (btuo *BankTransferUpdateOne) ClearTransactions() *BankTransferUpdateOne {
	btuo.mutation.ClearTransactions()
	return btuo
}

// RemoveTransactionIDs removes the "transactions" edge to Transaction entities by IDs.
func (btuo *BankTransferUpdateOne) RemoveTransactionIDs(ids ...uuid.UUID) *BankTransferUpdateOne {
	btuo.mutation.RemoveTransactionIDs(ids...)
	return btuo
}

// RemoveTransactions removes "transactions" edges to Transaction entities.
func (btuo *BankTransferUpdateOne) RemoveTransactions(t ...*Transaction) *BankTransferUpdateOne {
	ids := make([]uuid.UUID, len(t))
	for i := range t {
		ids[i] = t[i].ID
	}
	return btuo.RemoveTransactionIDs(ids...)
}

// Where appends a list predicates to the BankTransferUpdate builder.
func (btuo *BankTransferUpdateOne) Where(ps ...predicate.Bank_Transfer) *BankTransferUpdateOne {
	btuo.mutation.Where(ps...)
	return btuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (btuo *BankTransferUpdateOne) Select(field string, fields ...string) *BankTransferUpdateOne {
	btuo.fields = append([]string{field}, fields...)
	return btuo
}

// Save executes the query and returns the updated Bank_Transfer entity.
func (btuo *BankTransferUpdateOne) Save(ctx context.Context) (*Bank_Transfer, error) {
	btuo.defaults()
	return withHooks(ctx, btuo.sqlSave, btuo.mutation, btuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (btuo *BankTransferUpdateOne) SaveX(ctx context.Context) *Bank_Transfer {
	node, err := btuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (btuo *BankTransferUpdateOne) Exec(ctx context.Context) error {
	_, err := btuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (btuo *BankTransferUpdateOne) ExecX(ctx context.Context) {
	if err := btuo.Exec(ctx); err != nil {
		panic(err)
	}
}

// defaults sets the default values of the builder before save.
func (btuo *BankTransferUpdateOne) defaults() {
	if _, ok := btuo.mutation.UpdatedAt(); !ok {
		v := bank_transfer.UpdateDefaultUpdatedAt()
		btuo.mutation.SetUpdatedAt(v)
	}
}

// check runs all checks and user-defined validators on the builder.
func (btuo *BankTransferUpdateOne) check() error {
	if v, ok := btuo.mutation.Amount(); ok {
		if err := bank_transfer.AmountValidator(v); err != nil {
			return &ValidationError{Name: "amount", err: fmt.Errorf(`ent: validator failed for field "Bank_Transfer.amount": %w`, err)}
		}
	}
	if btuo.mutation.FromBankCleared() && len(btuo.mutation.FromBankIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Bank_Transfer.from_bank"`)
	}
	if btuo.mutation.ToBankCleared() && len(btuo.mutation.ToBankIDs()) > 0 {
		return errors.New(`ent: clearing a required unique edge "Bank_Transfer.to_bank"`)
	}
	return nil
}

func (btuo *BankTransferUpdateOne) sqlSave(ctx context.Context) (_node *Bank_Transfer, err error) {
	if err := btuo.check(); err != nil {
		return _node, err
	}
	_spec := sqlgraph.NewUpdateSpec(bank_transfer.Table, bank_transfer.Columns, sqlgraph.NewFieldSpec(bank_transfer.FieldID, field.TypeUUID))
	id, ok := btuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "Bank_Transfer.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := btuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, bank_transfer.FieldID)
		for _, f := range fields {
			if !bank_transfer.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != bank_transfer.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := btuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := btuo.mutation.Amount(); ok {
		_spec.SetField(bank_transfer.FieldAmount, field.TypeFloat64, value)
	}
	if value, ok := btuo.mutation.AddedAmount(); ok {
		_spec.AddField(bank_transfer.FieldAmount, field.TypeFloat64, value)
	}
	if value, ok := btuo.mutation.TransactionDate(); ok {
		_spec.SetField(bank_transfer.FieldTransactionDate, field.TypeTime, value)
	}
	if value, ok := btuo.mutation.Notes(); ok {
		_spec.SetField(bank_transfer.FieldNotes, field.TypeString, value)
	}
	if btuo.mutation.NotesCleared() {
		_spec.ClearField(bank_transfer.FieldNotes, field.TypeString)
	}
	if value, ok := btuo.mutation.CreatedAt(); ok {
		_spec.SetField(bank_transfer.FieldCreatedAt, field.TypeTime, value)
	}
	if value, ok := btuo.mutation.UpdatedAt(); ok {
		_spec.SetField(bank_transfer.FieldUpdatedAt, field.TypeTime, value)
	}
	if btuo.mutation.FromBankCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bank_transfer.FromBankTable,
			Columns: []string{bank_transfer.FromBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(bank.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := btuo.mutation.FromBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bank_transfer.FromBankTable,
			Columns: []string{bank_transfer.FromBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(bank.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if btuo.mutation.ToBankCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bank_transfer.ToBankTable,
			Columns: []string{bank_transfer.ToBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(bank.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := btuo.mutation.ToBankIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.M2O,
			Inverse: true,
			Table:   bank_transfer.ToBankTable,
			Columns: []string{bank_transfer.ToBankColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(bank.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	if btuo.mutation.TransactionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   bank_transfer.TransactionsTable,
			Columns: []string{bank_transfer.TransactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(transaction.FieldID, field.TypeUUID),
			},
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := btuo.mutation.RemovedTransactionsIDs(); len(nodes) > 0 && !btuo.mutation.TransactionsCleared() {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   bank_transfer.TransactionsTable,
			Columns: []string{bank_transfer.TransactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(transaction.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Clear = append(_spec.Edges.Clear, edge)
	}
	if nodes := btuo.mutation.TransactionsIDs(); len(nodes) > 0 {
		edge := &sqlgraph.EdgeSpec{
			Rel:     sqlgraph.O2M,
			Inverse: false,
			Table:   bank_transfer.TransactionsTable,
			Columns: []string{bank_transfer.TransactionsColumn},
			Bidi:    false,
			Target: &sqlgraph.EdgeTarget{
				IDSpec: sqlgraph.NewFieldSpec(transaction.FieldID, field.TypeUUID),
			},
		}
		for _, k := range nodes {
			edge.Target.Nodes = append(edge.Target.Nodes, k)
		}
		_spec.Edges.Add = append(_spec.Edges.Add, edge)
	}
	_node = &Bank_Transfer{config: btuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, btuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{bank_transfer.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	btuo.mutation.done = true
	return _node, nil
}
